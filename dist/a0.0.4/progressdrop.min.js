/* ProgressDrop is written by Simon Kalmi Claesson */
class ProgressBar{constructor(e,t="",s=!0,r=0,a=100){this.start=r,this.end=a,this.currentValue=r,this.container=e,this.showProgress=s,this.progressContainer=document.createElement("div"),this.progressContainer.className="progressdrop_container",this.progressContainer.style.width="100%",this.progressBar=document.createElement("div"),this.progressBar.className="progressdrop_bar",this.progressBar.style.width="0%",(t||s)&&(this.metaContainer=document.createElement("div"),this.metaContainer.className="progressdrop_meta",this.operationText=document.createElement("p"),this.operationText.textContent=t,this.percentageText=document.createElement("p"),this.percentageText.textContent=s?"0%":"",this.metaContainer.appendChild(this.operationText),this.metaContainer.appendChild(this.percentageText),this.progressContainer.appendChild(this.metaContainer)),this.progressContainer.appendChild(this.progressBar),e.appendChild(this.progressContainer)}calculatePercentage(){const e=this.end-this.start;return(this.currentValue-this.start)/e*100}update(e){this.currentValue=Math.max(this.start,Math.min(this.end,e));const t=this.calculatePercentage();this.progressBar.style.width=`${t}%`,this.showProgress&&this.metaContainer&&(this.percentageText.textContent=`${Math.round(t)}%`)}updateSameValue(){this.update(this.currentValue)}updateName(e){this.metaContainer&&(this.operationText.textContent=e)}progress(e){this.update(this.currentValue+e)}complete(){this.update(this.end)}reset(){this.update(this.start)}cleanUp(){this.complete(),setTimeout((()=>{this.progressContainer.remove()}),500)}getMethods(){return{update:e=>this.update(e),updateSameValue:()=>this.updateSameValue(),updateName:e=>this.updateName(e),progress:e=>this.progress(e),complete:()=>this.complete(),reset:()=>this.reset(),cleanUp:()=>this.cleanUp(),_obj_:this}}}class ProgressLoader{constructor(e){this.parentElement=e,this.progressBars=[]}cleanUpAll(){this.progressBars.forEach((e=>{e.cleanUp()}))}createProgressBar(e="",t=!0,s=0,r=100){const a=new ProgressBar(this.parentElement,e,t,s,r);return this.progressBars.push(a),a.getMethods()}async fetch(e,t=null,s=!0,r=!0,a=!1,n=!1){const o=t||"Downloading...",i=this.createProgressBar(o,s),p=await fetch(e);if(!p.ok)throw new Error(`HTTP error! status: ${p.status}`);if(!p.body){if(a)return p;throw new Error("ReadableStream not supported")}const h=p.body.getReader(),c=p.headers.get("content-length"),l=parseInt(c,10);let d=0;const u=new ReadableStream({start:async e=>{for(;;){const{done:t,value:s}=await h.read();if(t){r?i.cleanUp():i.complete(),e.close();break}d+=s.length,i.update(d/l*100),e.enqueue(s)}}}),g=new Response(u);return!0===n&&(g._progressdrop_obj_=i,g.getProgressObj=()=>i),g}async unzip(e,t=null,s=!0,r=!0,a=!1){const n=t||"Unzipping...",o=this.createProgressBar(n,s),i=new JSZip,p=await i.loadAsync(e,{async:!0,support:{arraybuffer:!0}}),h=Object.keys(p.files),c=h.length;let l=0;const d={};for(const e of h){const t=p.files[e];t.dir||(d[e]=await t.async("blob")),l++,o.update(l/c*100)}return r?o.cleanUp():o.complete(),!0===a&&(d._progressdrop_obj_=o,d.getProgressObj=()=>o),d}async zip(e,t=null,s=!0,r=!0,a=!1){const n=t||"Zipping...",o=this.createProgressBar(n,s),i=new JSZip,p=Object.entries(e),h=p.length;let c=0;for(const[e,t]of p)i.file(e,t),c++,o.update(c/h*100);r?o.cleanUp():o.complete();const l=await i.generateAsync({type:"blob"});return!0===a?(l._progressdrop_obj_=o,l.getProgressObj=()=>o,l):l}async timeDelay(e,t,s=null,r=!0,a=!0,n=!1){const o=s||"Processing...",i=this.createProgressBar(o,r,0,e),p=Date.now(),h=p+e,c=new Promise((e=>{const s=()=>{const r=Date.now(),n=r-p;i.update(n),r<h?setTimeout(s,t):(a?i.cleanUp():i.complete(),e())};s()}));return!0===n&&(c._progressdrop_obj_=i,c.getProgressObj=()=>i),c}}